
		
消息队列的应用(rocketMQ)

消息队列中的幂等性
消费者消费一条消息时耗时太久，已经超过了超时时间，mq认为消息处理失败，对消息进行重发，会导致消息重复消费
一般需要根据业务唯一键(订单ID)进行幂等控制(key),消费者将处理过的key进行记录，如果已经处理过则不处理这条消息
	上有发送数据更改的消息给集成适配层，
	应用之间解耦：上游发送数据到适配层，持久化后可以处理，如果用接口可能存在错误无法处理，导致集成失败
		异步：自己给自己发消息，权签人变动后，需要welink发送消息，还需要发送邮件，并行处理
	服务间通信：上游修改数据后，mq告知适配层，同步修改数据

redis锁
	排行榜： zset 
	缓存：加快访问速度
	分布式锁：定时任务执行，多个服务器上，避免一个还没执行完，下一个定时任务也开始了
	过期时间:分布式锁里面，一般都会添加过期时间，避免服务器宕机导致锁一直被占有的死锁情况
	用户头像缓存，设置过期时间

在工作中学到了什么
	代码性能上，锁的范围要尽量小，不要循环插入和调外部接口
		不考虑线程安全用StringBuilder等
		返回空集合用Collections.emptyList,不用new ArrayList(),不免不必要对象的产生
	关键节点上要记录日志
	开发自定义注解对接口进行优化实现数据库读写分离减轻数据库压力。
	单例模式，作为全局线程池
项目中的重难点
	注解失效场景
	数据库区别
		oracle,gauss使用不稳定的排序算法(速度快，快排，堆排序)，order by时要加上主键id
		oracle中空字符串等同于null
		oracle中number表示小树，mysql中double表示小数 
		mysql免费的，oracle和gauss数据库性能好
	数据库使用的不稳定排序算法，导致查询结果不一致，
		解决方式，查询时根据主键排序
	使用策略模式重构代码，比如考勤不同的职位考勤时间，都不一样，将策略封装到策略类中，可以代码重用，不用到处修改
数据库
	索引失效
	

redis中
负责针对居民满意度调查模块的问卷提交接口封装自定义注解配合Redis防止重复提交。
 负责使用EasyExcel框架实现系统中的文件导入导出功能，大文件导入采用多线程分批读取，加快响应速度，导出采用Xxl-Job进行添加定时任务异步导出。
	为什么要设置过期时间：持有锁的服务死机，将永远无法释放锁
	定时任务同步数据(A处理50条后释放锁，继续处理51-100，B获得了锁处理到了200-250，但是A才到52，老数据覆盖了新数据，)，用分布式锁分布式锁，到了过期时间，还没执行完，就释放了锁，下个定时任务又来了，导致锁被同时持有
		延长锁的过期时间，
		redisson中的看门狗机制(不写持有时间)，默认30秒过期时间，到了可以续上
		非必要还是写过期时间，确保尽早释放
	锁的范围把控，对招聘指标进行扣减并发请求，对数据操作无关的代码不用上锁，比如还要去请求人员主数据获得操作者信息等是否符合权限，可以提高接口性能；不仅要锁扣减的代码，其他相关的修改也要锁住，比如失效之类
	
	redis缓存更新中，先更新redis，再更新mysql,但是redis中的数据需要吊其他方法计算(耗时长)后才能得出，短时间更新多此会导致接口性能很慢(测试没通过)
		改成直接删除redis缓存，更新数据库，放到下次查寻的时候再计算后放入redis,存在数据不一致
		改成更新完mysql后再删一次缓存，
		增加500毫秒延迟时间后再删除，如果更新前被其他事务B查询，然后A删除了redis缓存，B又更新了redis缓存
	
	缓存穿透：性能测试中，造了很多假数据
	使用setnx做mq中的幂等校验，过期时间设置为几天
MQ
	重复消费原因：上游表单重复提交，未做去重，消息重复发送(根据业务唯一键过滤避免重复消费)
	重复消费，上游同一人两次入职进行扣减；入职之后要扣减招聘指标，通过MQ发送，通过入职指
	标进行判断是否已经扣减过，进行幂等，将指标存在redis中，
		业务逻辑错误，导致消费者消费失败，造成消息重复投递
	丢失消息：收到消息后，rocketMQ默认提交ACK，但是消费失败了，也没持久化就丢失了消息， 改成处理完业务后手动提交方式
	
	
mybatisPlus的好处
	自定义了封装方法：提供BaseMapper 接口，简化增删改查操作，适用于需要快速开发、简化 CRUD 操作、支持分页和逻辑删除等功能的项目。
	
	
性能方面
	redis keys和scan阻塞主线程
	多个链接查询，改成代码中查询2次，在代码中将链接查询的字段塞进去
	单据重复提交，将处理的单据号放到redis中(设置过期时间)，重复提交时先判断redis中是否存在，来避免
	
难以发现的性能问题
	缓存击穿，热点数据失效，大量请求到数据库，导致接口缓慢-请求时上锁(访问业务单元经常要访问到，很快失效，压测未通过)
	缓存雪崩： 预置到redis的热点数据，在同时失效，大量请求到数据库中
	数据库连接被慢sql语句占满，简单sql查询也要好几秒，用kill 进程ID 把运行较慢的SQL杀掉
	锁的颗粒度范围，不能整个方法都上锁，如请求人员，权限等相关数据， 小的颗粒度能提高并发性能
	
项目中遇到的重大问题，及解决方式
	mq重复消费，使用redis的setNx命令对业务id进行重复判断
	mq堆积，优化消费者逻辑，也通过消息给下游而不是通过接口调用等服务返回;增加消费者数量
	亮点：接收上游数据，同步给下游，同步每个表
		通过MQ接收
		做宽表，减少join,类似冗余字段
		和上游沟通减少MQ数量，将相关联的数据合并在一个mq中，而不是一个表的一条数据一个mq
		增加消费者服务器
		减少日志打印
		将收到的消息落表缓存，一分钟批量处理一次，处理后发mq通知下游，让下游调接口获取更新的数据，也减少了下游更新的次数(最终一致性，拿时间换性能)
		从原来的单挑插入，改成批量插入和更新，减少数据库建立连接的次数， 单条查询改成in，一次查询多条
		异步执行，人相关的数据有十多个表，使用线程池同时执行
	难点：数据库写入慢
		删除用处不大的索引
		读写分离
		
		
		
		
RPC:一个程序调用另个程序的函数(无感知，接近本地调用)；性能更好，不用关系通信细节(请求方式等)，内部使用高效的编码方式，减少数据量传输，复用连接，tcp，udp传输
	http：post请求调用，自己发起请求
对外的publicAPI需要注意什么
	认证方式不同
文件重复提交
	将文件转为MD5存储，并存到redis/数据库中，再次提交时判断是否重复
策略模式：根据传入的
工厂模式：对象创建和使用分离，不直接new,创建细节放在工厂方法中
单例模式

sync和lock的区别
脏读，不可重复读的区别
查询学士选课超过3门的学生id
	select student_id, count(*) count from student_t t1
		left join course_t t2 on t1.student_id = t2.studnet_id
		group by student_id having count >3
springboot如何实现自动装配
	@SpringBootApplication: 表示启动类
	@SpringBootConfiguration: 表示是启动类
	@ComponentScan: 组件扫描， 扫描组件和bean
	@EnableAutoConfiguration: 自动配置注解
	@Configuration :表示配置类，里面有@Bean注解
让bean在指定环境中生效


慢日志如何查询
	开启mysql慢日志 set global slow_query_log='ON'
	慢日志存放路径： slow_query_log_file 日志存放路径
	慢日志时间：log_query_time

生产环境中，线程池中的阻塞队列满了如何处理
	增加服务器节点，队列扩容
	对接口进行限流
	监控，查看日志定位问题
	重启服务器并调整线程池核心参数
	限制任务提交

线上cpu飙升如何排查(代码中存在死循环while(true))
	如果是上线导致，先回退到老版本
	先根据top命令查询占用cpu的进程pid
	jstack pid > show.txt   将线程的堆栈信息日志写到show.txt中
	top -p pid -h  查看进程中的哪个线程占cpu多 
	printf "%x" 线程id转为16进制
	less show.txt 根据线程id查询堆栈日志，定位到代码行
	最终定位到是死循环还是死锁
	
热点数据延迟双删后，大量请求到数据库，造成击穿
	请求时，检查缓存是否存在，不存在再上锁去数据库找，其他等待锁的线程枷锁失败等待200毫秒继续从缓存中读取

限流：通过限流机制（如令牌桶算法、漏桶算法）限制请求的频率，避免系统过载。

令牌桶算法
	令牌生成：令牌桶算法有一个令牌桶，系统会以固定的速率（例如每秒10个令牌）向桶中添加令牌。桶的容量是有限的，当桶满时，多余的令牌会被丢弃。
数据发送：当有数据需要发送时，会先从令牌桶中获取令牌。如果桶中有足够的令牌，就可以发送数据，并且消耗相应的令牌；如果没有足够的令牌，则需要等待，直到桶中有足够的令牌为止。
突发流量支持：令牌桶算法允许一定程度的突发流量。因为令牌桶可以存储一定数量的令牌，当有突发流量时，只要桶中有足够的令牌，就可以一次性发送多个数据包。

漏桶算法
	固定速率流出：漏桶算法有一个漏桶，数据以固定速率从桶中流出。无论数据进入桶的速度有多快，流出的速度始终保持恒定。
数据缓冲：当有数据进入时，会先存放在桶中。如果桶满了，后续进入的数据会被丢弃。
平滑流量：漏桶算法的主要作用是平滑流量。即使输入流量是突发的，输出流量也会保持恒定的速率。


