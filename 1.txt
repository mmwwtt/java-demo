

Pair 使用pair的好处，可以提取成公共处理，并且在方法内可以用作用域的变量，不用像方法一样进行传参

mysql 每次执行会自动提交事务


int day = 2;
String type = switch (day) {
    case 1, 2, 3 -> "工作日";
    case 6, 7 -> "周末";
    default -> "未知";
};
System.out.println(type);  // 输出：工作日



instanceof   判断泛型类型
    public <T> void checkValue(CheckStateDataInfo checkStateDataInfo, T value, List<String> levelField) {
        if (value instanceof String) {
            if (StringUtils.isEmpty((String) value)) {
                checkStateDataInfo.setCfgCmplt(STATE_VALUE_NO);
                objectJoin(checkStateDataInfo.getCheckInfo(), levelField, STATE_VALUE_IS_NULL_ERROR);
            }
        } else {
            if (Objects.isNull(value)) {
                checkStateDataInfo.setCfgCmplt(STATE_VALUE_NO);
                objectJoin(checkStateDataInfo.getCheckInfo(), levelField, STATE_VALUE_IS_NULL_ERROR);
            }
        }
    }

	optional 替换null判断
Optional.ofNullable(freeRadicaConfigList).ifPresent(list -> {
	ifPresent中list变量是当前stream流的对象，未必是最开始的，所以有存在的必要

object 接收 string 后instanceof 为什么类型
for循环中临时变量的作用域

//将 object转为string
if (object instanceof List<?>) {
    List<?> rawList = (List<?>) object;
    List<String> segmentList = new ArrayList<>();
    for (Object item : rawList) {
        if (item instanceof String) {
            segmentList.add((String) item);
        } else {
            // 处理非 String 元素（记录日志、抛异常或跳过）
        }
    }
    checkList(checkstateDataInfo, segmentList);
}
