使用锁会存在性能消耗
    能锁对象就不要锁类
    能锁区块，就不要锁整个方法体
    能用无锁数据结构，就不要用锁

高并发条件下，避免使用 == 作为终端/退出条件，容易产生等值判断击穿情况，推荐使用 大小于的区间判断来替代
优先推荐使用不可变对象在多线程之间传递信息
在使用阻塞等待获取锁的lock.lock()方法中，应该在try代码块外，并且在加锁方法和try代码块之间没有任何可能抛出异常的方法调用，避免枷锁成功后，在finally中无法解锁

如果使用锁，那么读写都要加锁，否则两个操作之间没有happend-before关系，会存在数据竞争
为避免数据竞争(data race)，要通过同步建立happens-before关系
    推荐使用volatile变量进行同步
    使用锁同步
    Thread.join()同步

避免在锁代码中调用RPC方法

应该回收自定义的ThreadLocal变量，在try-finally中调用remove()方法，否则会造成内存泄露


禁止使用Thread.stop()来终止线程，已过时，会释放该线程持有的所有锁，可能会导致锁保护的对象处于不一致状态

采用jdk1.5提供的新并发工具替代wait()和notify()
    Executor Framework
    并发集合 （Concurrent Collection）
    同步器(synchronizer),性能不苛刻时，推荐使用，读取简单

在异常条件下保证释放已持有的锁
禁止使用非线程安全的方法重写父类线程安全的方法
不要依赖线程调度器，线程优先级和yield()方法
    不同操作系统，不同厂商中的调度机制是不一样的，会导致代码可移植性差

    线程中断由业务代码来写作完成，慎用Thread.interrupt方法